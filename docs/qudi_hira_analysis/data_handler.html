<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>qudi_hira_analysis.data_handler API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>qudi_hira_analysis.data_handler</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import datetime
import logging
from pathlib import Path
from typing import List, TYPE_CHECKING, Callable

import pySPM

from qudi_hira_analysis.analysis_logic import AnalysisLogic
from qudi_hira_analysis.io_handler import IOHandler
from qudi_hira_analysis.measurement_dataclass import RawTimetrace, PulsedMeasurement, PulsedMeasurementDataclass, \
    LaserPulses, MeasurementDataclass

if TYPE_CHECKING:
    import pandas as pd
    import numpy as np

logging.basicConfig(format=&#39;%(name)s :: %(levelname)s :: %(message)s&#39;, level=logging.INFO)


class DataLoader(IOHandler):
    &#34;&#34;&#34;
    Interface to map measurement data loading methods in IOHandler to the automated data
    methods in DataHandler. Also provides a direct passthrough of the IOHandler methods.
    &#34;&#34;&#34;

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # Create callables used in measurement dataclasses
        self.default_qudi_loader: (Callable[[Path], pd.DataFrame], Callable[[Path], dict]) = (
            self.read_into_dataframe,
            self.read_qudi_parameters
        )
        self.confocal_qudi_loader: (Callable[[Path], np.ndarray], Callable[[Path], dict]) = (
            self.read_confocal_into_dataframe,
            self.read_qudi_parameters
        )
        self.pixelscanner_qudi_loader: (
            Callable[[Path], (pySPM.SPM_image, pySPM.SPM_image)], Callable[[Path], dict]) = (
            self.read_pixelscanner_data,
            self.read_qudi_parameters
        )
        self.trace_qudi_loader: (Callable[[Path], np.ndarray], Callable[[Path], dict]) = (
            self.read_into_ndarray_transposed,
            self.read_qudi_parameters
        )
        self.nanonis_loader: (Callable[[Path], pd.DataFrame], Callable[[Path], dict]) = (
            self.read_nanonis_data,
            self.read_nanonis_parameters
        )
        self.nanonis_spm_loader: (Callable[[Path], pySPM.SXM], None) = (
            self.read_nanonis_spm_data,
            None
        )
        self.bruker_spm_loader: (Callable[[Path], pySPM.Bruker], None) = (
            self.read_bruker_spm_data,
            None
        )
        self.temperature_loader: (Callable[[Path], pd.DataFrame], None) = (
            self.read_lakeshore_data,
            None
        )
        self.pys_loader: (Callable[[Path], dict], None) = (
            self.read_pys,
            None
        )
        self.pressure_loader: (Callable[[Path], pd.DataFrame], None) = (
            self.read_pfeiffer_data,
            None
        )


class DataHandler(DataLoader, AnalysisLogic):
    &#34;&#34;&#34;
    Handles automated data searching and extraction into dataclasses.

    Parameters:
        data_folder: Path to the data folder.
        figure_folder: Path to the figure folder.
        measurement_folder: Path to the measurement folder.

    Examples:
        Create an instance of the DataHandler class:

        &gt;&gt;&gt; dh = DataHandler(
        &gt;&gt;&gt;     data_folder=Path(&#39;C:\\&#39;&#39;, &#39;Data&#39;),
        &gt;&gt;&gt;     figure_folder=Path(&#39;C:\\&#39;&#39;, &#39;QudiHiraAnalysis&#39;),
        &gt;&gt;&gt;     measurement_folder=Path(&#39;20230101_Bakeout&#39;),
        &gt;&gt;&gt; )
    &#34;&#34;&#34;

    def __init__(
            self,
            data_folder: Path,
            figure_folder: Path,
            measurement_folder: Path = Path(),
            copy_measurement_folder_structure: bool = True,
    ):
        self.log = logging.getLogger(__name__)

        self.data_folder_path = self.__get_data_folder_path(data_folder, measurement_folder)

        if copy_measurement_folder_structure:
            self.figure_folder_path = self.__get_figure_folder_path(figure_folder, measurement_folder)
        else:
            self.figure_folder_path = self.__get_figure_folder_path(figure_folder, Path())

        super().__init__(base_read_path=self.data_folder_path, base_write_path=self.figure_folder_path)

        self.timestamp_format_str = &#34;%Y%m%d-%H%M-%S&#34;

    def __get_data_folder_path(self, data_folder: Path, folder_name: Path) -&gt; Path:
        &#34;&#34;&#34; Check if folder exists, if not, create it and return absolute folder paths. &#34;&#34;&#34;
        path = data_folder / folder_name

        if not path.exists():
            raise IOError(&#34;Data folder path does not exist.&#34;)

        self.log.info(f&#34;Data folder path is {path}&#34;)
        return path

    def __get_figure_folder_path(self, figure_folder: Path, folder_name: Path) -&gt; Path:
        &#34;&#34;&#34; Check if folder exists, if not, create it and return absolute folder paths. &#34;&#34;&#34;
        path = figure_folder / folder_name

        if not path.exists():
            path.mkdir()
            self.log.info(f&#34;Creating new output folder path {path}&#34;)
        else:
            self.log.info(f&#34;Figure folder path is {path}&#34;)
        return path

    def __tree(self, dir_path: Path, prefix: str = &#39;&#39;):
        &#34;&#34;&#34;
        A recursive generator, given a directory Path object
        will yield a visual tree structure line by line
        with each line prefixed by the same characters
        &#34;&#34;&#34;
        # prefix components:
        space = &#39;    &#39;
        branch = &#39;│   &#39;
        # pointers:
        tee = &#39;├── &#39;
        last = &#39;└── &#39;

        contents = list(dir_path.iterdir())
        # contents each get pointers that are ├── with a final └── :
        pointers = [tee] * (len(contents) - 1) + [last]
        for pointer, path in zip(pointers, contents):
            yield prefix + pointer + path.name
            if path.is_dir():  # extend the prefix and recurse:
                extension = branch if pointer == tee else space
                # i.e. space because last, └── , above so no more |
                yield from self.__tree(path, prefix=prefix + extension)

    def data_folder_tree(self):
        &#34;&#34;&#34; Print a tree of the data folder. &#34;&#34;&#34;
        for line in self.__tree(self.data_folder_path):
            print(line)

    def figure_folder_tree(self):
        &#34;&#34;&#34; Print a tree of the figure folder. &#34;&#34;&#34;
        for line in self.__tree(self.figure_folder_path):
            print(line)

    def _get_measurement_filepaths(
            self,
            measurement: str,
            extension: str,
            exclude_str: str | None = None
    ) -&gt; list[Path]:
        &#34;&#34;&#34;
        List all measurement files for a single measurement type, regardless of date
        within a similar set (i.e. top level folder).
        &#34;&#34;&#34;
        filepaths: List[Path] = []

        for path in self.data_folder_path.rglob(&#34;*&#34;):
            if path.is_file() and measurement.lower() in str(path).lower():
                if exclude_str is None or exclude_str not in str(path):
                    if extension:
                        if path.suffix == extension:
                            filepaths.append(path)
                    else:
                        filepaths.append(path)
        return filepaths

    def __load_qudi_measurements_into_dataclass(
            self,
            measurement_str: str,
            pulsed: bool,
            extension: str
    ) -&gt; dict[str: MeasurementDataclass]:

        if pulsed:
            filtered_filepaths = []
            timestamps = set()

            # Get set of unique timestamps containing pulsed_measurement_str
            for filepath in self._get_measurement_filepaths(measurement=measurement_str, extension=extension,
                                                            exclude_str=&#34;image_1.dat&#34;):
                filename = filepath.name
                if measurement_str in filename:
                    timestamps.add(filename[:16])
                    filtered_filepaths.append(filepath)

            pulsed_measurement_data: dict[str: MeasurementDataclass] = {}

            for ts in timestamps:
                pm, lp, rt = None, None, None

                for filepath in filtered_filepaths:
                    filename = filepath.name
                    if filename.startswith(ts):
                        if str(filename).endswith(&#34;laser_pulses.dat&#34;):
                            lp = LaserPulses(filepath=filepath, loaders=self.trace_qudi_loader)
                        elif str(filename).endswith(&#34;pulsed_measurement.dat&#34;):
                            pm = PulsedMeasurement(filepath=filepath, loaders=self.default_qudi_loader)
                        elif str(filename).endswith(&#34;raw_timetrace.dat&#34;):
                            rt = RawTimetrace(filepath=filepath, loaders=self.trace_qudi_loader)

                    if lp and pm and rt:
                        break

                pulsed_measurement_data[ts] = (
                    MeasurementDataclass(
                        timestamp=datetime.datetime.strptime(ts, self.timestamp_format_str),
                        pulsed=PulsedMeasurementDataclass(
                            measurement=pm,
                            laser_pulses=lp,
                            timetrace=rt
                        )
                    )
                )
            return pulsed_measurement_data
        else:
            if measurement_str.lower() == &#34;confocal&#34;:
                loaders = self.confocal_qudi_loader
                exclude_str = &#34;xy_data.dat&#34;
            elif measurement_str.lower() == &#34;pixelscanner&#34;:
                loaders = self.pixelscanner_qudi_loader
                exclude_str = None
            else:
                loaders = self.default_qudi_loader
                exclude_str = None

            measurement_data: dict[str: MeasurementDataclass] = {}

            for filepath in self._get_measurement_filepaths(measurement_str, extension, exclude_str):
                ts = filepath.name[:16]
                measurement_data[ts] = (
                    MeasurementDataclass(
                        filepath=filepath,
                        timestamp=datetime.datetime.strptime(ts, self.timestamp_format_str),
                        _loaders=loaders
                    )
                )
            return measurement_data

    def __load_standard_measurements_into_dataclass(
            self,
            measurement_str: str,
            extension: str
    ) -&gt; dict[str: MeasurementDataclass]:
        measurement_list: dict[str: MeasurementDataclass] = {}

        # Try and infer measurement type
        if measurement_str.lower() == &#34;temperature-monitoring&#34;:
            loaders = self.temperature_loader
            extension = &#34;.xls&#34;
            exclude_str = None
        elif measurement_str.lower() == &#34;pressure-monitoring&#34;:
            loaders = self.pressure_loader
            extension = &#34;.txt&#34;
            exclude_str = None
        elif measurement_str == &#34;frq-sweep&#34;:
            loaders = self.nanonis_loader
            exclude_str = None
        elif extension == &#34;.sxm&#34;:
            loaders = self.nanonis_spm_loader
            exclude_str = None
        elif extension == &#34;.pys&#34;:
            loaders = self.pys_loader
            exclude_str = None
        elif extension == &#34;.001&#34;:
            loaders = self.bruker_spm_loader
            exclude_str = None
        else:
            loaders = self.default_qudi_loader
            exclude_str = None

        for filepath in self._get_measurement_filepaths(measurement_str, extension, exclude_str):
            timestamp = datetime.datetime.fromtimestamp(filepath.stat().st_mtime)
            self.log.warning(&#34;Extracting timestamp from file modified time, may not be accurate.&#34;)
            ts = datetime.datetime.strftime(timestamp, self.timestamp_format_str)
            measurement_list[ts] = (
                MeasurementDataclass(
                    filepath=filepath,
                    timestamp=timestamp,
                    _loaders=loaders
                )
            )
        return measurement_list

    def load_measurements(
            self,
            measurement_str: str,
            qudi: bool = True,
            pulsed: bool = False,
            extension: str = &#34;.dat&#34;
    ) -&gt; dict[str: MeasurementDataclass]:
        &#34;&#34;&#34;
        Lazy load all measurements of a given type into a dictionary of dataclasses.

        Args:
            measurement_str: The name of the measurement type to load e.g. t1, t2, confocal etc. Recursively searches through the path defined by data_folder and measurement_folder
            qudi: Whether the measurement is a qudi measurement (default: False).
            pulsed: Whether the measurement is a pulsed measurement (default: False).
            extension: The file extension of the measurement files (default: .dat).

        Returns:
            dict: A dictionary of dataclasses containing the measurement data.

        Examples:
            `dh` is an instance of the `DataHandler` class.

            Load all T1 measurements:

            &gt;&gt;&gt; dh.load_measurements(measurement_str=&#34;ODMR&#34;, pulsed=True)

            Load all confocal data:

            &gt;&gt;&gt; dh.load_measurements(measurement_str=&#34;Confocal&#34;)

            Load all temperature monitoring data:

            &gt;&gt;&gt; dh.load_measurements(measurement_str=&#34;Temperature&#34;)

            Load all pressure monitoring data:

            &gt;&gt;&gt; dh.load_measurements(measurement_str=&#34;Pressure&#34;)
        &#34;&#34;&#34;

        measurement_str = measurement_str.lower()
        if qudi:
            return self.__load_qudi_measurements_into_dataclass(measurement_str, pulsed=pulsed, extension=&#34;.dat&#34;)
        else:
            return self.__load_standard_measurements_into_dataclass(measurement_str, extension=extension)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="qudi_hira_analysis.data_handler.DataHandler"><code class="flex name class">
<span>class <span class="ident">DataHandler</span></span>
<span>(</span><span>data_folder: Path, figure_folder: Path, measurement_folder: Path = PosixPath('.'), copy_measurement_folder_structure: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Handles automated data searching and extraction into dataclasses.</p>
<h2 id="parameters">Parameters</h2>
<p>data_folder: Path to the data folder.
figure_folder: Path to the figure folder.
measurement_folder: Path to the measurement folder.</p>
<h2 id="examples">Examples</h2>
<p>Create an instance of the DataHandler class:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; dh = DataHandler(
&gt;&gt;&gt;     data_folder=Path('C:\'', 'Data'),
&gt;&gt;&gt;     figure_folder=Path('C:\'', 'QudiHiraAnalysis'),
&gt;&gt;&gt;     measurement_folder=Path('20230101_Bakeout'),
&gt;&gt;&gt; )
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataHandler(DataLoader, AnalysisLogic):
    &#34;&#34;&#34;
    Handles automated data searching and extraction into dataclasses.

    Parameters:
        data_folder: Path to the data folder.
        figure_folder: Path to the figure folder.
        measurement_folder: Path to the measurement folder.

    Examples:
        Create an instance of the DataHandler class:

        &gt;&gt;&gt; dh = DataHandler(
        &gt;&gt;&gt;     data_folder=Path(&#39;C:\\&#39;&#39;, &#39;Data&#39;),
        &gt;&gt;&gt;     figure_folder=Path(&#39;C:\\&#39;&#39;, &#39;QudiHiraAnalysis&#39;),
        &gt;&gt;&gt;     measurement_folder=Path(&#39;20230101_Bakeout&#39;),
        &gt;&gt;&gt; )
    &#34;&#34;&#34;

    def __init__(
            self,
            data_folder: Path,
            figure_folder: Path,
            measurement_folder: Path = Path(),
            copy_measurement_folder_structure: bool = True,
    ):
        self.log = logging.getLogger(__name__)

        self.data_folder_path = self.__get_data_folder_path(data_folder, measurement_folder)

        if copy_measurement_folder_structure:
            self.figure_folder_path = self.__get_figure_folder_path(figure_folder, measurement_folder)
        else:
            self.figure_folder_path = self.__get_figure_folder_path(figure_folder, Path())

        super().__init__(base_read_path=self.data_folder_path, base_write_path=self.figure_folder_path)

        self.timestamp_format_str = &#34;%Y%m%d-%H%M-%S&#34;

    def __get_data_folder_path(self, data_folder: Path, folder_name: Path) -&gt; Path:
        &#34;&#34;&#34; Check if folder exists, if not, create it and return absolute folder paths. &#34;&#34;&#34;
        path = data_folder / folder_name

        if not path.exists():
            raise IOError(&#34;Data folder path does not exist.&#34;)

        self.log.info(f&#34;Data folder path is {path}&#34;)
        return path

    def __get_figure_folder_path(self, figure_folder: Path, folder_name: Path) -&gt; Path:
        &#34;&#34;&#34; Check if folder exists, if not, create it and return absolute folder paths. &#34;&#34;&#34;
        path = figure_folder / folder_name

        if not path.exists():
            path.mkdir()
            self.log.info(f&#34;Creating new output folder path {path}&#34;)
        else:
            self.log.info(f&#34;Figure folder path is {path}&#34;)
        return path

    def __tree(self, dir_path: Path, prefix: str = &#39;&#39;):
        &#34;&#34;&#34;
        A recursive generator, given a directory Path object
        will yield a visual tree structure line by line
        with each line prefixed by the same characters
        &#34;&#34;&#34;
        # prefix components:
        space = &#39;    &#39;
        branch = &#39;│   &#39;
        # pointers:
        tee = &#39;├── &#39;
        last = &#39;└── &#39;

        contents = list(dir_path.iterdir())
        # contents each get pointers that are ├── with a final └── :
        pointers = [tee] * (len(contents) - 1) + [last]
        for pointer, path in zip(pointers, contents):
            yield prefix + pointer + path.name
            if path.is_dir():  # extend the prefix and recurse:
                extension = branch if pointer == tee else space
                # i.e. space because last, └── , above so no more |
                yield from self.__tree(path, prefix=prefix + extension)

    def data_folder_tree(self):
        &#34;&#34;&#34; Print a tree of the data folder. &#34;&#34;&#34;
        for line in self.__tree(self.data_folder_path):
            print(line)

    def figure_folder_tree(self):
        &#34;&#34;&#34; Print a tree of the figure folder. &#34;&#34;&#34;
        for line in self.__tree(self.figure_folder_path):
            print(line)

    def _get_measurement_filepaths(
            self,
            measurement: str,
            extension: str,
            exclude_str: str | None = None
    ) -&gt; list[Path]:
        &#34;&#34;&#34;
        List all measurement files for a single measurement type, regardless of date
        within a similar set (i.e. top level folder).
        &#34;&#34;&#34;
        filepaths: List[Path] = []

        for path in self.data_folder_path.rglob(&#34;*&#34;):
            if path.is_file() and measurement.lower() in str(path).lower():
                if exclude_str is None or exclude_str not in str(path):
                    if extension:
                        if path.suffix == extension:
                            filepaths.append(path)
                    else:
                        filepaths.append(path)
        return filepaths

    def __load_qudi_measurements_into_dataclass(
            self,
            measurement_str: str,
            pulsed: bool,
            extension: str
    ) -&gt; dict[str: MeasurementDataclass]:

        if pulsed:
            filtered_filepaths = []
            timestamps = set()

            # Get set of unique timestamps containing pulsed_measurement_str
            for filepath in self._get_measurement_filepaths(measurement=measurement_str, extension=extension,
                                                            exclude_str=&#34;image_1.dat&#34;):
                filename = filepath.name
                if measurement_str in filename:
                    timestamps.add(filename[:16])
                    filtered_filepaths.append(filepath)

            pulsed_measurement_data: dict[str: MeasurementDataclass] = {}

            for ts in timestamps:
                pm, lp, rt = None, None, None

                for filepath in filtered_filepaths:
                    filename = filepath.name
                    if filename.startswith(ts):
                        if str(filename).endswith(&#34;laser_pulses.dat&#34;):
                            lp = LaserPulses(filepath=filepath, loaders=self.trace_qudi_loader)
                        elif str(filename).endswith(&#34;pulsed_measurement.dat&#34;):
                            pm = PulsedMeasurement(filepath=filepath, loaders=self.default_qudi_loader)
                        elif str(filename).endswith(&#34;raw_timetrace.dat&#34;):
                            rt = RawTimetrace(filepath=filepath, loaders=self.trace_qudi_loader)

                    if lp and pm and rt:
                        break

                pulsed_measurement_data[ts] = (
                    MeasurementDataclass(
                        timestamp=datetime.datetime.strptime(ts, self.timestamp_format_str),
                        pulsed=PulsedMeasurementDataclass(
                            measurement=pm,
                            laser_pulses=lp,
                            timetrace=rt
                        )
                    )
                )
            return pulsed_measurement_data
        else:
            if measurement_str.lower() == &#34;confocal&#34;:
                loaders = self.confocal_qudi_loader
                exclude_str = &#34;xy_data.dat&#34;
            elif measurement_str.lower() == &#34;pixelscanner&#34;:
                loaders = self.pixelscanner_qudi_loader
                exclude_str = None
            else:
                loaders = self.default_qudi_loader
                exclude_str = None

            measurement_data: dict[str: MeasurementDataclass] = {}

            for filepath in self._get_measurement_filepaths(measurement_str, extension, exclude_str):
                ts = filepath.name[:16]
                measurement_data[ts] = (
                    MeasurementDataclass(
                        filepath=filepath,
                        timestamp=datetime.datetime.strptime(ts, self.timestamp_format_str),
                        _loaders=loaders
                    )
                )
            return measurement_data

    def __load_standard_measurements_into_dataclass(
            self,
            measurement_str: str,
            extension: str
    ) -&gt; dict[str: MeasurementDataclass]:
        measurement_list: dict[str: MeasurementDataclass] = {}

        # Try and infer measurement type
        if measurement_str.lower() == &#34;temperature-monitoring&#34;:
            loaders = self.temperature_loader
            extension = &#34;.xls&#34;
            exclude_str = None
        elif measurement_str.lower() == &#34;pressure-monitoring&#34;:
            loaders = self.pressure_loader
            extension = &#34;.txt&#34;
            exclude_str = None
        elif measurement_str == &#34;frq-sweep&#34;:
            loaders = self.nanonis_loader
            exclude_str = None
        elif extension == &#34;.sxm&#34;:
            loaders = self.nanonis_spm_loader
            exclude_str = None
        elif extension == &#34;.pys&#34;:
            loaders = self.pys_loader
            exclude_str = None
        elif extension == &#34;.001&#34;:
            loaders = self.bruker_spm_loader
            exclude_str = None
        else:
            loaders = self.default_qudi_loader
            exclude_str = None

        for filepath in self._get_measurement_filepaths(measurement_str, extension, exclude_str):
            timestamp = datetime.datetime.fromtimestamp(filepath.stat().st_mtime)
            self.log.warning(&#34;Extracting timestamp from file modified time, may not be accurate.&#34;)
            ts = datetime.datetime.strftime(timestamp, self.timestamp_format_str)
            measurement_list[ts] = (
                MeasurementDataclass(
                    filepath=filepath,
                    timestamp=timestamp,
                    _loaders=loaders
                )
            )
        return measurement_list

    def load_measurements(
            self,
            measurement_str: str,
            qudi: bool = True,
            pulsed: bool = False,
            extension: str = &#34;.dat&#34;
    ) -&gt; dict[str: MeasurementDataclass]:
        &#34;&#34;&#34;
        Lazy load all measurements of a given type into a dictionary of dataclasses.

        Args:
            measurement_str: The name of the measurement type to load e.g. t1, t2, confocal etc. Recursively searches through the path defined by data_folder and measurement_folder
            qudi: Whether the measurement is a qudi measurement (default: False).
            pulsed: Whether the measurement is a pulsed measurement (default: False).
            extension: The file extension of the measurement files (default: .dat).

        Returns:
            dict: A dictionary of dataclasses containing the measurement data.

        Examples:
            `dh` is an instance of the `DataHandler` class.

            Load all T1 measurements:

            &gt;&gt;&gt; dh.load_measurements(measurement_str=&#34;ODMR&#34;, pulsed=True)

            Load all confocal data:

            &gt;&gt;&gt; dh.load_measurements(measurement_str=&#34;Confocal&#34;)

            Load all temperature monitoring data:

            &gt;&gt;&gt; dh.load_measurements(measurement_str=&#34;Temperature&#34;)

            Load all pressure monitoring data:

            &gt;&gt;&gt; dh.load_measurements(measurement_str=&#34;Pressure&#34;)
        &#34;&#34;&#34;

        measurement_str = measurement_str.lower()
        if qudi:
            return self.__load_qudi_measurements_into_dataclass(measurement_str, pulsed=pulsed, extension=&#34;.dat&#34;)
        else:
            return self.__load_standard_measurements_into_dataclass(measurement_str, extension=extension)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qudi_hira_analysis.data_handler.DataLoader" href="#qudi_hira_analysis.data_handler.DataLoader">DataLoader</a></li>
<li><a title="qudi_hira_analysis.io_handler.IOHandler" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler">IOHandler</a></li>
<li><a title="qudi_hira_analysis.analysis_logic.AnalysisLogic" href="analysis_logic.html#qudi_hira_analysis.analysis_logic.AnalysisLogic">AnalysisLogic</a></li>
<li>qudi_hira_analysis._qudi_fit_logic.FitLogic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qudi_hira_analysis.data_handler.DataHandler.data_folder_tree"><code class="name flex">
<span>def <span class="ident">data_folder_tree</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Print a tree of the data folder.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_folder_tree(self):
    &#34;&#34;&#34; Print a tree of the data folder. &#34;&#34;&#34;
    for line in self.__tree(self.data_folder_path):
        print(line)</code></pre>
</details>
</dd>
<dt id="qudi_hira_analysis.data_handler.DataHandler.figure_folder_tree"><code class="name flex">
<span>def <span class="ident">figure_folder_tree</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Print a tree of the figure folder.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def figure_folder_tree(self):
    &#34;&#34;&#34; Print a tree of the figure folder. &#34;&#34;&#34;
    for line in self.__tree(self.figure_folder_path):
        print(line)</code></pre>
</details>
</dd>
<dt id="qudi_hira_analysis.data_handler.DataHandler.load_measurements"><code class="name flex">
<span>def <span class="ident">load_measurements</span></span>(<span>self, measurement_str: str, qudi: bool = True, pulsed: bool = False, extension: str = '.dat') ‑> dict[slice(<class 'str'>, <class '<a title="qudi_hira_analysis.measurement_dataclass.MeasurementDataclass" href="measurement_dataclass.html#qudi_hira_analysis.measurement_dataclass.MeasurementDataclass">MeasurementDataclass</a>'>, None)]</span>
</code></dt>
<dd>
<div class="desc"><p>Lazy load all measurements of a given type into a dictionary of dataclasses.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>measurement_str</code></strong></dt>
<dd>The name of the measurement type to load e.g. t1, t2, confocal etc. Recursively searches through the path defined by data_folder and measurement_folder</dd>
<dt><strong><code>qudi</code></strong></dt>
<dd>Whether the measurement is a qudi measurement (default: False).</dd>
<dt><strong><code>pulsed</code></strong></dt>
<dd>Whether the measurement is a pulsed measurement (default: False).</dd>
<dt><strong><code>extension</code></strong></dt>
<dd>The file extension of the measurement files (default: .dat).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary of dataclasses containing the measurement data.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p><code>dh</code> is an instance of the <code><a title="qudi_hira_analysis.data_handler.DataHandler" href="#qudi_hira_analysis.data_handler.DataHandler">DataHandler</a></code> class.</p>
<p>Load all T1 measurements:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; dh.load_measurements(measurement_str=&quot;ODMR&quot;, pulsed=True)
</code></pre>
<p>Load all confocal data:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; dh.load_measurements(measurement_str=&quot;Confocal&quot;)
</code></pre>
<p>Load all temperature monitoring data:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; dh.load_measurements(measurement_str=&quot;Temperature&quot;)
</code></pre>
<p>Load all pressure monitoring data:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; dh.load_measurements(measurement_str=&quot;Pressure&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_measurements(
        self,
        measurement_str: str,
        qudi: bool = True,
        pulsed: bool = False,
        extension: str = &#34;.dat&#34;
) -&gt; dict[str: MeasurementDataclass]:
    &#34;&#34;&#34;
    Lazy load all measurements of a given type into a dictionary of dataclasses.

    Args:
        measurement_str: The name of the measurement type to load e.g. t1, t2, confocal etc. Recursively searches through the path defined by data_folder and measurement_folder
        qudi: Whether the measurement is a qudi measurement (default: False).
        pulsed: Whether the measurement is a pulsed measurement (default: False).
        extension: The file extension of the measurement files (default: .dat).

    Returns:
        dict: A dictionary of dataclasses containing the measurement data.

    Examples:
        `dh` is an instance of the `DataHandler` class.

        Load all T1 measurements:

        &gt;&gt;&gt; dh.load_measurements(measurement_str=&#34;ODMR&#34;, pulsed=True)

        Load all confocal data:

        &gt;&gt;&gt; dh.load_measurements(measurement_str=&#34;Confocal&#34;)

        Load all temperature monitoring data:

        &gt;&gt;&gt; dh.load_measurements(measurement_str=&#34;Temperature&#34;)

        Load all pressure monitoring data:

        &gt;&gt;&gt; dh.load_measurements(measurement_str=&#34;Pressure&#34;)
    &#34;&#34;&#34;

    measurement_str = measurement_str.lower()
    if qudi:
        return self.__load_qudi_measurements_into_dataclass(measurement_str, pulsed=pulsed, extension=&#34;.dat&#34;)
    else:
        return self.__load_standard_measurements_into_dataclass(measurement_str, extension=extension)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qudi_hira_analysis.data_handler.DataLoader" href="#qudi_hira_analysis.data_handler.DataLoader">DataLoader</a></b></code>:
<ul class="hlist">
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.read_bruker_spm_data" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_bruker_spm_data">read_bruker_spm_data</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.read_confocal_into_dataframe" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_confocal_into_dataframe">read_confocal_into_dataframe</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.read_csv" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_csv">read_csv</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.read_excel" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_excel">read_excel</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.read_into_dataframe" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_into_dataframe">read_into_dataframe</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.read_into_ndarray" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_into_ndarray">read_into_ndarray</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.read_into_ndarray_transposed" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_into_ndarray_transposed">read_into_ndarray_transposed</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.read_lakeshore_data" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_lakeshore_data">read_lakeshore_data</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.read_nanonis_data" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_nanonis_data">read_nanonis_data</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.read_nanonis_parameters" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_nanonis_parameters">read_nanonis_parameters</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.read_nanonis_spm_data" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_nanonis_spm_data">read_nanonis_spm_data</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.read_oceanoptics_data" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_oceanoptics_data">read_oceanoptics_data</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.read_pfeiffer_data" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_pfeiffer_data">read_pfeiffer_data</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.read_pixelscanner_data" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_pixelscanner_data">read_pixelscanner_data</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.read_pkl" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_pkl">read_pkl</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.read_pys" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_pys">read_pys</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.read_qudi_parameters" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_qudi_parameters">read_qudi_parameters</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.save_df" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.save_df">save_df</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.save_figures" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.save_figures">save_figures</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.save_pkl" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.save_pkl">save_pkl</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataLoader.save_pys" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.save_pys">save_pys</a></code></li>
</ul>
</li>
<li><code><b><a title="qudi_hira_analysis.analysis_logic.AnalysisLogic" href="analysis_logic.html#qudi_hira_analysis.analysis_logic.AnalysisLogic">AnalysisLogic</a></b></code>:
<ul class="hlist">
<li><code><a title="qudi_hira_analysis.analysis_logic.AnalysisLogic.analyse_mean" href="analysis_logic.html#qudi_hira_analysis.analysis_logic.AnalysisLogic.analyse_mean">analyse_mean</a></code></li>
<li><code><a title="qudi_hira_analysis.analysis_logic.AnalysisLogic.analyse_mean_norm" href="analysis_logic.html#qudi_hira_analysis.analysis_logic.AnalysisLogic.analyse_mean_norm">analyse_mean_norm</a></code></li>
<li><code><a title="qudi_hira_analysis.analysis_logic.AnalysisLogic.analyse_mean_reference" href="analysis_logic.html#qudi_hira_analysis.analysis_logic.AnalysisLogic.analyse_mean_reference">analyse_mean_reference</a></code></li>
<li><code><a title="qudi_hira_analysis.analysis_logic.AnalysisLogic.average_raster_odmr_pixels" href="analysis_logic.html#qudi_hira_analysis.analysis_logic.AnalysisLogic.average_raster_odmr_pixels">average_raster_odmr_pixels</a></code></li>
<li><code><a title="qudi_hira_analysis.analysis_logic.AnalysisLogic.fit" href="analysis_logic.html#qudi_hira_analysis.analysis_logic.AnalysisLogic.fit">fit</a></code></li>
<li><code><a title="qudi_hira_analysis.analysis_logic.AnalysisLogic.fit_function" href="analysis_logic.html#qudi_hira_analysis.analysis_logic.AnalysisLogic.fit_function">fit_function</a></code></li>
<li><code><a title="qudi_hira_analysis.analysis_logic.AnalysisLogic.fit_raster_odmr" href="analysis_logic.html#qudi_hira_analysis.analysis_logic.AnalysisLogic.fit_raster_odmr">fit_raster_odmr</a></code></li>
<li><code><a title="qudi_hira_analysis.analysis_logic.AnalysisLogic.optimize_raster_odmr_params" href="analysis_logic.html#qudi_hira_analysis.analysis_logic.AnalysisLogic.optimize_raster_odmr_params">optimize_raster_odmr_params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qudi_hira_analysis.data_handler.DataLoader"><code class="flex name class">
<span>class <span class="ident">DataLoader</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Interface to map measurement data loading methods in IOHandler to the automated data
methods in DataHandler. Also provides a direct passthrough of the IOHandler methods.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataLoader(IOHandler):
    &#34;&#34;&#34;
    Interface to map measurement data loading methods in IOHandler to the automated data
    methods in DataHandler. Also provides a direct passthrough of the IOHandler methods.
    &#34;&#34;&#34;

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # Create callables used in measurement dataclasses
        self.default_qudi_loader: (Callable[[Path], pd.DataFrame], Callable[[Path], dict]) = (
            self.read_into_dataframe,
            self.read_qudi_parameters
        )
        self.confocal_qudi_loader: (Callable[[Path], np.ndarray], Callable[[Path], dict]) = (
            self.read_confocal_into_dataframe,
            self.read_qudi_parameters
        )
        self.pixelscanner_qudi_loader: (
            Callable[[Path], (pySPM.SPM_image, pySPM.SPM_image)], Callable[[Path], dict]) = (
            self.read_pixelscanner_data,
            self.read_qudi_parameters
        )
        self.trace_qudi_loader: (Callable[[Path], np.ndarray], Callable[[Path], dict]) = (
            self.read_into_ndarray_transposed,
            self.read_qudi_parameters
        )
        self.nanonis_loader: (Callable[[Path], pd.DataFrame], Callable[[Path], dict]) = (
            self.read_nanonis_data,
            self.read_nanonis_parameters
        )
        self.nanonis_spm_loader: (Callable[[Path], pySPM.SXM], None) = (
            self.read_nanonis_spm_data,
            None
        )
        self.bruker_spm_loader: (Callable[[Path], pySPM.Bruker], None) = (
            self.read_bruker_spm_data,
            None
        )
        self.temperature_loader: (Callable[[Path], pd.DataFrame], None) = (
            self.read_lakeshore_data,
            None
        )
        self.pys_loader: (Callable[[Path], dict], None) = (
            self.read_pys,
            None
        )
        self.pressure_loader: (Callable[[Path], pd.DataFrame], None) = (
            self.read_pfeiffer_data,
            None
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qudi_hira_analysis.io_handler.IOHandler" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler">IOHandler</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="qudi_hira_analysis.data_handler.DataHandler" href="#qudi_hira_analysis.data_handler.DataHandler">DataHandler</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qudi_hira_analysis.io_handler.IOHandler" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler">IOHandler</a></b></code>:
<ul class="hlist">
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.read_bruker_spm_data" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_bruker_spm_data">read_bruker_spm_data</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.read_confocal_into_dataframe" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_confocal_into_dataframe">read_confocal_into_dataframe</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.read_csv" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_csv">read_csv</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.read_excel" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_excel">read_excel</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.read_into_dataframe" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_into_dataframe">read_into_dataframe</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.read_into_ndarray" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_into_ndarray">read_into_ndarray</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.read_into_ndarray_transposed" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_into_ndarray_transposed">read_into_ndarray_transposed</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.read_lakeshore_data" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_lakeshore_data">read_lakeshore_data</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.read_nanonis_data" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_nanonis_data">read_nanonis_data</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.read_nanonis_parameters" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_nanonis_parameters">read_nanonis_parameters</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.read_nanonis_spm_data" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_nanonis_spm_data">read_nanonis_spm_data</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.read_oceanoptics_data" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_oceanoptics_data">read_oceanoptics_data</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.read_pfeiffer_data" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_pfeiffer_data">read_pfeiffer_data</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.read_pixelscanner_data" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_pixelscanner_data">read_pixelscanner_data</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.read_pkl" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_pkl">read_pkl</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.read_pys" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_pys">read_pys</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.read_qudi_parameters" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.read_qudi_parameters">read_qudi_parameters</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.save_df" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.save_df">save_df</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.save_figures" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.save_figures">save_figures</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.save_pkl" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.save_pkl">save_pkl</a></code></li>
<li><code><a title="qudi_hira_analysis.io_handler.IOHandler.save_pys" href="io_handler.html#qudi_hira_analysis.io_handler.IOHandler.save_pys">save_pys</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="qudi_hira_analysis" href="index.html">qudi_hira_analysis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="qudi_hira_analysis.data_handler.DataHandler" href="#qudi_hira_analysis.data_handler.DataHandler">DataHandler</a></code></h4>
<ul class="">
<li><code><a title="qudi_hira_analysis.data_handler.DataHandler.data_folder_tree" href="#qudi_hira_analysis.data_handler.DataHandler.data_folder_tree">data_folder_tree</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataHandler.figure_folder_tree" href="#qudi_hira_analysis.data_handler.DataHandler.figure_folder_tree">figure_folder_tree</a></code></li>
<li><code><a title="qudi_hira_analysis.data_handler.DataHandler.load_measurements" href="#qudi_hira_analysis.data_handler.DataHandler.load_measurements">load_measurements</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qudi_hira_analysis.data_handler.DataLoader" href="#qudi_hira_analysis.data_handler.DataLoader">DataLoader</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>